from itertools import chain, cycle
from os.path import basename

from .logging import log
from .utils import comment, format_requirement


class OutputWriter(object):
    def __init__(self, header, annotate):
        self.header = header
        self.annotate = annotate

    def _sort_key(self, ireq):
        return (not ireq.editable, str(ireq.req).lower())

    def comment(self, text):
        self.write_line(comment(text))

    def write_line(self, line, fg=None):
        log.info(line, fg=fg)

    def write_header(self, src_file):
        if self.header:
            self.comment('#')
            self.comment('# This file is autogenerated by pip-compile')
            self.comment('# Make changes in {}, then run this to update:'.format(basename(src_file)))
            self.comment('#')
            self.comment('#    pip-compile {}'.format(basename(src_file)))
            self.comment('#')

    def write_index_options(self, default_index_url, index_urls):
        emitted = False
        option_values = chain(['--index-url'], cycle(['--extra-index-url']))
        for option, index_url in zip(option_values, index_urls):
            if index_url == default_index_url:
                continue
            self.write_line('{} {}'.format(option, index_urls[0]))
            emitted = True
        if emitted:
            self.write_line('')  # extra line of whitespace

    def write(self, dst_file, src_file, default_index_url, index_urls,
              results, reverse_dependencies, primary_packages):
        self.write_header(src_file)
        self.write_index_options(default_index_url, index_urls)

        UNSAFE_PACKAGES = {'setuptools', 'distribute', 'pip'}
        unsafe_packages = {r for r in results if r.name in UNSAFE_PACKAGES}
        packages = {r for r in results if r.name not in UNSAFE_PACKAGES}

        packages = sorted(packages, key=self._sort_key)
        unsafe_packages = sorted(unsafe_packages, key=self._sort_key)

        for ireq in packages:
            line = self._format_requirement(ireq, reverse_dependencies, primary_packages)
            self.write_line(line)

        if unsafe_packages:
            self.write_line('')
            self.comment('# The following packages are commented out because they are ')
            self.comment('# considered to be unsafe in a requirements file:')

            for ireq in unsafe_packages:
                line = self._format_requirement(ireq, reverse_dependencies, primary_packages)
                line = comment('# ' + line)
                self.write_line(line)

    def _format_requirement(self, ireq, reverse_dependencies, primary_packages):
        line = format_requirement(ireq)
        if not self.annotate or ireq.name in primary_packages:
            return line

        # Annotate what packages this package is required by
        required_by = reverse_dependencies.get(ireq.name, [])
        if required_by:
            line = line.ljust(24)
            annotation = ', '.join(sorted(required_by))
            line += comment('  # via ' + annotation)
        return line
